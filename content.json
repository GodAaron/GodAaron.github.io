[{"title":"Executor框架","date":"2018-08-03T02:53:57.000Z","path":"2018/08/03/Executor框架/","text":"文章总阅读量次 ###Executor框架 Executor框架继承关系图如下： ###Callable接口 在介绍线程池之前，我们先来看一下Callable接口，它只有一个call()方法； 在jdk5之前，我们只有一个Runnable接口，用来定义任务，将它交给一个Thread对象去执行；但是Runnable接口的run()方法是没有返回值的，也不能抛出任何检查性异常，有些时候不方便。 我们可以利用Callable接口，来定义有返回值并且可抛出检查异常的任务，将它交给ExecutorService去执行； ExecutorService.submit()方法将返回一个Future对象，Future.get()方法可获取结果。 submit方法和execute方法的区别： 接收的参数不一样 ; 12345voide execute(Runnable command);&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)；&lt;T&gt; Future&lt;T&gt; submit(Runnable task,T result)；Future&lt;?&gt; submit(Runnable task)； submit()有返回值，而execute()没有； submit()可以进行Exception处理； ExecutorService接口ExecutorService接口继承自Executor公共接口，它提供了丰富的线程池控制方法，比如shutdown()用于平滑关闭线程池，submit()用于提交Callable任务（相比于Runnabe任务，它可以有返回值、可以抛出异常）。 AbstractExecutorService抽象类AbstractExecutorService抽象类实现了Executor接口的submit、invoke系列方法； ThreadPoolExecutor类ThreadPoolExecutor核心类，可以创建自定义线程池，下面是其主要方法: 1234567891011121314151617181920212223242526272829303132333435/*构造方法*/public ThreadPoolExecutor(int corePoolSize, //核心线程数的最大值int maximumPoolSize,//可同时拥有的最大线程数int keepAliveTime,//空闲线程的存活时间TimeUnit unit, //keepAliveTime单位BlockingQueue&lt;Runnable&gt;workQueue)// 用于缓存任务的阻塞队列)&#123;this(corePoolSize,maximumPoolSize,keepAliveTime,unit,workQueue,Executors.defaultThreadFactory(),defaultHandler)；&#125;/*构造方法*/public ThreadPoolExecutor( int corePoolSize, //核心线程数的最大值 int maximumPoolSize,//可同时拥有的最大线程数 long keepAliveTime, //空闲线程存活的时间 TimeUnit unit,// keepAliveTime单位 BlockingQueue&lt;Runnable&gt; workQueue,///缓存任务的阻塞队列 ThreadFactory threadFactory//用于生产线程的线程工厂 )&#123; this(corePoolSize,maximumPoolSize,keepAliveTime,unit, workQueue,threadFactory,defaultHandler); &#125; /*构造函数*/public ThreadPoolExecutor( int corePoolSize, // 核心线程数的最大值 int maximumPoolSize, // 可同时拥有的最大线程数 long keepAliveTime, // 空闲线程的存活时间 * TimeUnit unit, // keepAliveTime 单位 BlockingQueue&lt;Runnable&gt; workQueue, // 用于缓存任务的阻塞队列 ThreadFactory threadFactory, // 指定产生线程的线程工厂 RejectedExecutionHandler handler);// 指定拒绝接收新任务的策略, 空闲超时策略默认针对\"临时\"线程，即超过 corePoolSize 数的线程，核心线程即使空闲也不会超时终止, 拒绝策略是指当 workQueue 已满，且池内线程数达到 maximumPoolSize 时拒绝接受新任务采取的策略 */) 构造函数各个参数的含义： corePoolSize: 线程池中的核心线程数，也就是正式员工数量； maximumPoolSize:线程池中能同时拥有的最大线程数（maximumPoolSize-corePoolSize = 临时线程数）； keepAliveTime:空闲线程的存活时间（默认针对临时线程） unit: keepAliveTime单位","tags":[{"name":"juc包","slug":"juc包","permalink":"http://yoursite.com/tags/juc包/"},{"name":"并发","slug":"并发","permalink":"http://yoursite.com/tags/并发/"}]},{"title":"J.U.C包简介","date":"2018-08-03T02:53:57.000Z","path":"2018/08/03/J-U-C包简介/","text":"文章总阅读量次 ###摘要 JUC即java.util.concurrent，是JSR 166标准规范的一个实现，作者是Doug Lea大神。JUC框架是Java 5引入的，我们最熟悉的线程池机制就是在这个包里。 本文主要包含以下几个部分： 第一部分：JUC框架的整体介绍 JUC框架的介绍JUC框架主要包含： Excutor框架（线程池、Callable、Future）,任务的执行和调度框架； AbstractQueuedSynchronizer(AQS框架)，JUC中实现锁和同步机制的基础； Locks&amp;Condition(锁和条件变量)，比Synchronized、wait、notify更细粒度的锁机制； Synchronizers(同步器),主要用于协助线程同步，有CountDownLatch、CyclicBarrier、Semaphore、Exchanger； Atomic Variables(原子变量)，方便程序员在多线程的环境下，无锁的进行原子操作，核心操作是CAS。CAS即compare and swap，指的是将预期值与当前变量的值比较，如果相等则使用新值替换，否则不操作； BlockingQueue(阻塞队列),阻塞队列提供了可阻塞的入队和出队操作，如果队列满了，入队操作将阻塞直到有空间可用，如果队列空了，出队操作将阻塞直到有元素可用； Concurrent Collections(并发容器),在jdk1.5之前，为了线程安全，我们一般都是使用同步容器，同步容器的缺点是：对所有容器状态的访问都是串行化，严重降低了并发性；某些复合操作，仍然需要加锁来保护；迭代期间，若其它线程并发修改容器，会抛ConcurrentModificationException异常，即快速失败机制； Fork/Join并行计算框架，这块内容是在1.7引入的，可以方便利用多核平台的计算能力，简化并行程序的编写； TimeUnit枚举，TimeUnit提供了可读性更好的线程暂停操作，以及方便的时间单位转换方法；","tags":[{"name":"juc包","slug":"juc包","permalink":"http://yoursite.com/tags/juc包/"},{"name":"并发","slug":"并发","permalink":"http://yoursite.com/tags/并发/"}]},{"title":"Reference详解","date":"2018-07-30T09:17:45.000Z","path":"2018/07/30/Reference详解/","text":"","tags":[]},{"title":"IOC详解","date":"2018-07-29T02:04:52.000Z","path":"2018/07/29/IOC详解/","text":"文章总阅读量次","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"},{"name":"ioc","slug":"ioc","permalink":"http://yoursite.com/tags/ioc/"}]},{"title":"Runnable、Callable、Future、FutureTask详解","date":"2018-07-26T07:41:20.000Z","path":"2018/07/26/Runnable、Callable、Future、FutureTask详解/","text":"文章总阅读量次 摘 要Java中存在Runnable、Callable、Future、FutureTask这几个和线程相关的概念，本文简要介绍它们在线程中的作用。 文章共分以下五个部分。 第一部分主要介绍Java对线程这个概念的支持。 第二部分介绍Runnable的概念和使用。 第三部分介绍Callable的概念和使用。 第四部分介绍Future的概念和使用。 第五部分介绍FutureTask的概念和使用。 Java对线程的支持线程是cup调度的最小单元，线程是进程中的一个实体，是被系统独立调度和分派的基本单位。线程自己基本上不拥有系统资源，但它可以与同属一个进程的其他线程共享进程所拥有的全部资源。所以线程是轻量级的任务，它们之间的通信和转换只需要较小的系统开销。 java语言中线程使用Thread类来对这线程进行抽象。Thread线程类封装了所有需要的线程操作控制。通过对多线程执行代码抽取作为线程要执行的任务，java使用Runnable这个类来对线程要执行的任务进行抽象。 Thread为何要实现Runnable？ Thread和Runnable一个作为线程的抽象，一个作为多线程要执行的任务抽象，而让Thread实现Runnable接口对这样的设计感觉很疑惑。那为何Thread要实现Runnable接口？网上的一种说法是java历史原因，如果你有答案可以告知。 Runnable接口Runnable接口是对多线程执行任务的抽线，它只有一个run()方法，线程要执行的任务写在里面，该函数没有返回值。一个Runnable接口的实例传到一个Thread实例中，通过thread的start()方法用来启动线程执行这个任务。 1234567891011121314public class RunnableTest &#123; public static void main(String[] args) &#123; Runnable runnable = new RunnableInstance(); Thread t = new Thread(runnable); t.start(); &#125; static class RunnableInstance implements Runnable &#123; @Override public void run() &#123; System.out.println(\"runnable任务\"); &#125; &#125;&#125; Callable接口Callable接口与Runnable接口的功能大致相似，Callable中有一个call()函数，但是call()函数有返回值，而Runnable的run()函数不能将结果返回给客户程序。Callable的声明如下： 12345678910111213141516171819202122232425262728293031package java.util.concurrent;/** * A task that returns a result and may throw an exception. * Implementors define a single method with no arguments called * &#123;@code call&#125;. * * &lt;p&gt;The &#123;@code Callable&#125; interface is similar to &#123;@link * java.lang.Runnable&#125;, in that both are designed for classes whose * instances are potentially executed by another thread. A * &#123;@code Runnable&#125;, however, does not return a result and cannot * throw a checked exception. * * &lt;p&gt;The &#123;@link Executors&#125; class contains utility methods to * convert from other common forms to &#123;@code Callable&#125; classes. * * @see Executor * @since 1.5 * @author Doug Lea * @param &lt;V&gt; the result type of method &#123;@code call&#125; */@FunctionalInterfacepublic interface Callable&lt;V&gt; &#123; /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;&#125; Future接口Executor接口就是Runnable和Callable的调度容器，而Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果、设置结果操作。其中get()方法会阻塞，直到任务返回结果。Future声明如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/*** @see FutureTask * @see Executor * @since 1.5 * @author Doug Lea * @param &lt;V&gt; The result type returned by this Future's &lt;tt&gt;get&lt;/tt&gt; method */public interface Future&lt;V&gt; &#123; /** * Attempts to cancel execution of this task. This attempt will * fail if the task has already completed, has already been cancelled, * or could not be cancelled for some other reason. If successful, * and this task has not started when &lt;tt&gt;cancel&lt;/tt&gt; is called, * this task should never run. If the task has already started, * then the &lt;tt&gt;mayInterruptIfRunning&lt;/tt&gt; parameter determines * whether the thread executing this task should be interrupted in * an attempt to stop the task. * */ boolean cancel(boolean mayInterruptIfRunning); /** * Returns &lt;tt&gt;true&lt;/tt&gt; if this task was cancelled before it completed * normally. */ boolean isCancelled(); /** * Returns &lt;tt&gt;true&lt;/tt&gt; if this task completed. * */ boolean isDone(); /** * Waits if necessary for the computation to complete, and then * retrieves its result. * * @return the computed result */ V get() throws InterruptedException, ExecutionException; /** * Waits if necessary for at most the given time for the computation * to complete, and then retrieves its result, if available. * * @param timeout the maximum time to wait * @param unit the time unit of the timeout argument * @return the computed result */ V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; jdk api对 Future的定义：A Future represents the result of an asynchronous computation（Future代表异步计算的结果）。里面定义了对结果的各种操作，如获取、取消。 FutureTask接口 FutureTask是一个RunnableFuture, 而RunnableFuture既实现了Runnable接口又实现了Future接口，类图如下： 此外，RunnableTask 也可以包装Runnable和Callable, 由构造函数注入依赖： 1234567891011public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable &#125; public FutureTask(Runnable runnable, V result) &#123; this.callable = Executors.callable(runnable, result); this.state = NEW; // ensure visibility of callable &#125; 可以看到Runnable注入会被Executors.callable()函数转换成Callable类型，即FutureTask最终都是执行Callable类型的任务。 因此FutureTask既是Future、Runnable，又是包装了Callable( 如果是Runnable最终也会被转换为Callable )， 它是这两者的合体。","tags":[{"name":"并发","slug":"并发","permalink":"http://yoursite.com/tags/并发/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"mysql数据库索引背后的数据结构和算法","date":"2018-07-26T03:16:27.000Z","path":"2018/07/26/mysql数据库索引背后的数据结构和算法/","text":"文章总阅读量次 摘 要MySQL索引","tags":[{"name":"索引","slug":"索引","permalink":"http://yoursite.com/tags/索引/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"Java并发编程实战-第三章对象共享","date":"2018-07-12T13:18:21.000Z","path":"2018/07/12/第三章、对象共享/","text":"文章总阅读量次 概念知识点： 可见性 synchronized不仅能实现操作原子性和确定临界区，还有另一个重要的方面“内存可见性”。 12345678910111213141516171819202122232425package com.xyy.two;/** * @author xyy * @date 2018/7/12 */public class Novisibility &#123; private static boolean ready; private static int number; private static class ReaderThread extends Thread&#123; public void run()&#123; while (!ready)&#123; Thread.yield(); &#125; System.out.println(number); &#125; &#125; public static void main(String[] args) throws Exception &#123; new ReaderThread().start(); Thread.sleep(100); number = 42; ready = true; &#125;&#125; ​ 本程序中主线程进行写操作，从线程进行读操作。可能出现的情况： ​ 1、程序一直循环，从线程永远看不到主线程的读操作 ​ 2、程序按期望输出42 ​ 3、程序输出0 程序输出0最为奇怪，这是因为读线程只看到了写入ready的值，却没看到之后写入的number的值，这种现象称为“重排序”。当主线程写入number,然后再没有同步的情况下写入ready，那么从线程看到的顺序可能与写入的顺序相反。 ​ 重点:: 内置锁可以用于确保某线程以一种可以预测的方式来查看另一线程的执行结果。为了确保所有的线程都能看到共享变量的最新值，可以在所有执行读操作和写操作的线程上同时加上一把锁。 （1） Synchronized: 保证可见性和原子性 ​ 在java内存模型中，synchronized规定，线程在加锁时，先清空工作内存，在主内存中拷贝最新的副本到工作内存中，执行完代码，将更改后的共享变量的值刷新到主内存中，释放互斥锁。 ​ synchronized 不禁止指令重排，但只要同步代码块中的共享变量对其它线程不可见，那么我们就不必担心它引起的副作用。 123456789101112public class Singleton&#123; private Singleton()&#123; &#125; static class SingletonHolder&#123; public static final Singleton INSTANCE = new Singleton(); &#125; private static Singleton getInstance()&#123; return SingletonHolder.INSTANCE; &#125;&#125; ​ 这个单例模式是线程安全的，尽管INSTANCE变量没有用volatitle修饰，但是在类初始化的过程中JVM在Class文件被加载后，被线程使用之前会执行类的初始化。这个过程会通过一个初始化锁进行同步（对于每一个类或者接口，都有唯一的初始化锁），也就是说只有一个线程能获取该锁并执行这段代码，其它线程无法访问到INSTANCE，故重排序对其他线程不可见，整个过程是线程安全的。 （2） Volatile: 保证可见性，但不能保证原子性 Volatitle实现内存可见性是通过store和load指令完成的。也就是volatitle变量执行写操作时，会在写操作后加入一条store指令，即强迫线程将最新的值刷新到主存中；而读操作时，会加入一套load指令，即强迫从主内存中读取变量值。 ​ 当且仅当满足以下所有条件时，才应该使用volatile变量： 对变量的写入操作不依赖变量的当前值，或者你能确保只有单线程更新变量的值。 该变量不会与其他状态变量一起纳入不变性条件中。 在访问变量时 不需要加锁。 发布与逸出 “发布”一个对象的意思是指，使对象能够在当前作用域之外的代码中使用。例如，将一个指向该对象的引用保存到其他代码可以访问的地方，或者在某一个非私有的方法中返回该引用，或者将引用传递到其他类的方法中。 12345678910对象在构建期间逸出public class ThisEscape()&#123; public ThisEscape(EventSource event)&#123; event.register(new EventListenter()&#123; public void onEvent(Event e)&#123; doSomeThing(e); &#125; &#125;) &#125;&#125; 这段代码通过内名内部类发布EventListener，但是由于内部类会持有封装它的外部类的引用this，所以ThisEscape的一个对象也发布出去了，从而导致对象未构造完成就发布出去的逸出。对象只有在构造函数返回后才可以预知的。 安全发布对象 1、通过静态初始化器初始化对象的引用； 2、将对象的引用保存到volatitle类型或者AtomicReference对象中 3、将对象的引用保存到某个正确构造对象的final类型域中 4、将对象的引用保存到某个锁保护的域中。","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"}]},{"title":"Java并发编程实战-第二章线程安全","date":"2018-07-09T04:18:21.000Z","path":"2018/07/09/第二章、线程安全/","text":"文章总阅读量次 概念知识点： 对象状态 对象状态指存储在对象状态变量中的数据。对象状态也可能包括其他 依赖对象的域。 如HashMap的状态不仅存储在HashMap对象本身，还存储在Map.Entry对象中。 共享、可变 “共享”意味着变量可以由多个线程同时访问，“可变”意味着变量的值在其生命周期内可以发生变化。 可变变量没有合适的同步导致的线程安全问题可以通过三种方式修改： 1、将这个变量变成线程私有 2、将状态修改为不可变 3、在多线程访问状态变量时使用同步 竞态条件 在并发编程中，由于不恰当的执行时序而出现不正确的结果，这种情况叫竞态条件。 当某个计算的正确性取决于多线程的交替执行时序，就会发生竞态条件。而正确结果也就取决于“运气”。 最常见的竞态条件类型就是“先检查再执行”，而这次检查可能是一个无效的观察结果。这种观察失效就是大多数竞态条件的本质—基于一种可能失效的观察结果来作出判断或执行某个计算。 针对复合操作，要避免静态条件，“先检查后执行”和“读取-修改-写入”等操作必须是原子的。可以通过加锁机制来实现。 内置锁 Java提供了一种内置锁的机制支持原子性：同步代码块（Synchronized Block）。 同步代码块包含两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。每个java对象都可以用作一个实现同步的锁，这些锁称为内置锁或监视器锁。线程在进入同步代码块自动获取锁，退出同步代码块自动释放锁。 获得内置锁的唯一途径就是进入由锁保护的同步代码块或方法。 内置锁是可重入梭，可以用锁来保护变量的状态。一种常见的错误认识：只有写入共享变量时才需要使用同步，然而多线程访问可变状态变量，也需要锁来保护。 重入 当某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。重入的一种实现方法是为每个锁关联一个获取计数值和一个所有者线程，当计数值为0时，这个锁就被认为是没有被任务线程持有。当请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值为1。如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数值相应递减。当计数值为0时，锁将被释放。 什么是线程安全？网上的各种“定义”中最核心的概念就是：正确性。如果对正确性定义不明确，线程安全的定义也是模糊的。正确性的含义是，某各类的行为与规范完全一致。在定义了“正确性”的含义后，就可以得到线程安全的含义： 当多个线程访问某各类时，这个类始终能表现出正确的行为，那么这个类就是线程安全的。 哪些情况是线程安全的？ 无状态的对象一定是线程安全的 多状态变量如何确保一致性？要保证状态的一致性，需要在单个原子操作中更新所有相关的状态变量。如果单个原子操作中只更新了部分变量的状态，整体上仍不是线程安全的","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"}]}]